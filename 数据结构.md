## <center>数据结构

#### 线段树
朴素线段树
区间修改，区间查询
```
ll a[N];
int n, m;
inline int lc(int x)
{
	return x << 1;
}
inline int rc(int x)
{
	return x << 1 | 1;
}
struct Seg
{
	ll l, r, sum, tag;
	
} seg[N * 4];

void push_up(int cur)
{
	seg[cur].sum = seg[lc(cur)].sum + seg[rc(cur)].sum;
}
void build(int cur, int l, int r)
{
	seg[cur] = {l, r, 0, 0};
	if (l == r)
	{
		seg[cur].sum = a[l];
	}
	else
	{
		int mid = l + r >> 1;
		build(lc(cur), l, mid);
		build(rc(cur), mid + 1, r);
		push_up(cur);
	}
}
void push_down(int cur)
{
	auto &root = seg[cur], &ls = seg[lc(cur)], &rs = seg[rc(cur)];
	if (root.tag)
	{
		ls.tag += root.tag;
		rs.tag += root.tag;
		ls.sum += (ll)(ls.r - ls.l + 1) * root.tag;
		rs.sum += (ll)(rs.r - rs.l + 1) * root.tag;
		root.tag = 0;
	}
}
void add(int cur, int l, int r, int val)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].tag += val;
		seg[cur].sum += (ll)(seg[cur].r - seg[cur].l + 1) * val;
	}
	else
	{
		push_down(cur);
		int mid = seg[cur].l + seg[cur].r >> 1;
		if (l <= mid)
		{
			add(lc(cur), l, r, val);
		}
		if (r > mid)
		{
			add(rc(cur), l, r, val);
		}
		push_up(cur);
	}
}
ll que(int cur, int l, int r)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		return seg[cur].sum;
	}
	push_down(cur);
	ll ans = 0;
	int mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)
	{
		ans += que(lc(cur), l, r);
	}
	if (r > mid)
	{
		ans += que(rc(cur), l, r);
	}
	return ans;
}
```
    