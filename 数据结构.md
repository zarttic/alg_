[![hackmd-github-sync-badge](https://hackmd.io/ww9FEyhoQHmg1NHcomB-Ow/badge)](https://hackmd.io/ww9FEyhoQHmg1NHcomB-Ow)
## <center>数据结构

### 线段树
#### 朴素线段树
##### 区间修改加减，区间查询
```
ll a[N];
int n, m;
inline int lc(int x)
{
	return x << 1;
}
inline int rc(int x)
{
	return x << 1 | 1;
}
struct Seg
{
	ll l, r, sum, tag;
	
} seg[N * 4];

void push_up(int cur)
{
	seg[cur].sum = seg[lc(cur)].sum + seg[rc(cur)].sum;
}
void build(int cur, int l, int r)
{
	seg[cur] = {l, r, 0, 0};
	if (l == r)
	{
		seg[cur].sum = a[l];
	}
	else
	{
		int mid = l + r >> 1;
		build(lc(cur), l, mid);
		build(rc(cur), mid + 1, r);
		push_up(cur);
	}
}
void push_down(int cur)
{
	auto &root = seg[cur], &ls = seg[lc(cur)], &rs = seg[rc(cur)];
	if (root.tag)
	{
		ls.tag += root.tag;
		rs.tag += root.tag;
		ls.sum += (ll)(ls.r - ls.l + 1) * root.tag;
		rs.sum += (ll)(rs.r - rs.l + 1) * root.tag;
		root.tag = 0;
	}
}
void add(int cur, int l, int r, int val)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].tag += val;
		seg[cur].sum += (ll)(seg[cur].r - seg[cur].l + 1) * val;
	}
	else
	{
		push_down(cur);
		int mid = seg[cur].l + seg[cur].r >> 1;
		if (l <= mid)
		{
			add(lc(cur), l, r, val);
		}
		if (r > mid)
		{
			add(rc(cur), l, r, val);
		}
		push_up(cur);
	}
}
ll que(int cur, int l, int r)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		return seg[cur].sum;
	}
	push_down(cur);
	ll ans = 0;
	int mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)
	{
		ans += que(lc(cur), l, r);
	}
	if (r > mid)
	{
		ans += que(rc(cur), l, r);
	}
	return ans;
}
```
##### 区间加，乘
要点：要先乘后加
模板参考
    [线段树加乘操作](https://www.luogu.com.cn/problem/P3373)
```
#include<bits/stdc++.h>

#define IO std::ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
const int N = 1000005;
using namespace std;
using ll = long long;
inline int lc(int x)
{
	return x << 1;
}
inline int rc(int x)
{
	return x << 1 | 1;
}
ll n, m, a[N], p;
struct Seg
{
	ll sum, l, r, mul, add;
} seg[N];
void pp(ll cur)
{
	seg[cur].sum = (seg[lc(cur)].sum + seg[rc(cur)].sum) % p;
}
void build(ll cur, ll l, ll r)
{
	seg[cur].l = l;
	seg[cur].r = r;
	seg[cur].mul = 1;
	if (l == r)
	{
		seg[cur].sum = a[l] % p;
		return;
	}
	int mid = l + r >> 1;
	build(lc(cur), l, mid);
	build(rc(cur), mid + 1, r);
	pp(cur);
}
void pd(ll cur)
{
	//先乘后加
	seg[lc(cur)].sum = (ll)(seg[cur].mul * seg[lc(cur)].sum + ((seg[lc(cur)].r - seg[lc(cur)].l + 1) * seg[cur].add) % p) % p;
	seg[rc(cur)].sum = (ll)(seg[cur].mul * seg[rc(cur)].sum + ((seg[rc(cur)].r - seg[rc(cur)].l + 1) * seg[cur].add) % p) % p;

	seg[lc(cur)].mul = (ll)(seg[cur].mul * seg[lc(cur)].mul) % p;
	seg[rc(cur)].mul = (ll)(seg[cur].mul * seg[rc(cur)].mul) % p;

	seg[lc(cur)].add = (ll)(seg[lc(cur)].add * seg[cur].mul + seg[cur].add) % p;
	seg[rc(cur)].add = (ll)(seg[rc(cur)].add * seg[cur].mul + seg[cur].add) % p;

	//清零处理
	seg[cur].mul = 1;
	seg[cur].add = 0;
}
void add(ll cur, ll l, ll r, ll k)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].add = (seg[cur].add + k) % p;
		seg[cur].sum = (ll)(seg[cur].sum + k * (seg[cur].r - seg[cur].l + 1)) % p;
		return;
	}
	pd(cur);
	ll mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)add(lc(cur), l, r, k);
	if (mid < r)add(rc(cur), l, r, k);
	pp(cur);
}
void mul(ll cur, ll l, ll r, ll k)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].add = (seg[cur].add * k) % p;
		seg[cur].mul = (seg[cur].mul * k) % p;
		seg[cur].sum = (seg[cur].sum * k) % p;
		return;
	}
	pd(cur);
	ll mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)mul(lc(cur), l, r, k);
	if (mid < r)mul(rc(cur), l, r, k);
	pp(cur);
}
ll que(ll cur, ll l, ll r)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		return seg[cur].sum;
	}
	pd(cur);
	ll ans = 0;
	ll mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)ans = (ans + que(lc(cur), l, r)) % p;
	if (mid < r)ans =  (ans + que(rc(cur), l, r)) % p;
	return ans;
}
void slove()
{
	cin >> n >> m >> p;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	build(1, 1, n);
	while (m--)
	{
		ll op, x, y, z;
		cin >> op ;
		if (op == 1)
		{
			cin >> x >> y >> z;
			mul(1, x, y, z);
		}
		else if (op == 2)
		{
			cin >> x >> y >> z;
			add(1, x, y, z);
		}
		else
		{
			cin >> x >> y;
			cout << que(1, x, y) << '\n';
		}
	}
}
int main()
{
	IO
	int _T = 1;
//	cin >> _T;
	while (_T--)
	{
		slove();
	}
	return (0 - 0);
}
```
### 珂朵莉树
#### 节点
一个节点表示一个值相同的区间
```
struct Node
{
	int l, r;
	mutable int v;
	Node (const int &_l, const int &_r, const int & _v)
	{
		l = _l;
		r = _r;
		v = _v;
	}
	inline bool operator < (const Node & a) const
	{
		return l < a.l;
	}
}
set<Node> odt;
```
#### split操作
将原本包含在点$x$的区间$[l,r]$分裂成为两个区间$[l,x)$和$[x,r]$并返回指向后者的迭代器
```
auto split(int x)
{
	if (x > n) return odt.end();
	auto it = --odt.upper_bound(Node{x, 0, 0}); //找首个不小于x的节点
	if (it -> l == x) return it; //没找到直接返回
	int l = it -> l, r = it -> r, v = it -> v;
	odt.erase(it);
	odt.insert(Node(l, x - 1, v));
	//insert函数返回pair，其中的first是新插入结点的迭代器
	return odt.insert(Node(x, r, v)).first;
}
```
#### assign
用于对一段区间进行赋值（可以替换成其他操作），这个是保证复杂度的关键。
这个里面也可以进行其他的操作，但是复杂度就没有办法保证了（也就是暴力计算类似于分块
```
void assign(int l, int r, int v)
{
	auto itr = split(r + 1), itl = split(l);
	odt.erase(itl, itr);
	odt.insert(Node(l, r, v));
}
```
#### 一些操作
##### 区间第$K$小
```
int rank(int l, int r, int k)
{
	//值 ，值的个数 第k小也要算上重复的
	vector<pair<int, int>> vec;
	auto itr = split(r + 1), itl = split(l);
	for (; itl != itr; ++itl)
	{
		vec.push_back({itl -> v, itl -> r - itl->l + 1});
	}
	sort(begin(vec), end(vec));
	for (auto it : vec)
	{
		k -= it.second;
		if (k <= 0) return it->first;
	}
}
```
##### 区间取反
对$[l,r]$里面的取反$O(r-l)$
```
void assign(int l, int r)
{
	auto itr = split(r + 1), itl = split(l);
	for (; itl != itr; itl++)itl->v ^= 1;
}
```

---

---


## <center>图论
### 简单图
#### 数组存图（邻接表）
h数组是邻接表的头它的下表是当前节点的标号，值是当前结点第一条边的编号（其实是最后加入的那一条边。

e数组是边的集合，它的下标是当前边的编号，数值是当前边的终点；
    
ne是nextedge，如果ne是-1表示当前结点没有下一条边，ne的下标是当前边的编号，数值是当前结点的下一条边的编号，idx用于保存每一条边的上一条边的编号。
    
这样我们就知道了当前结点的第一条边是几，这个边的终点是那个结点，该节点的下一条边编号是几，那么邻接表就完成了
```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int h[N], e[N], ne[N], idx;
void add(int a, int b)
{
	//图的创建
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}
void dfs(int u, int father)
{
	//图的遍历
	cout << u << endl;
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (j != father)
		{
			dfs(j, u);
		}
	}
}
int main()
{
	int n;
	cin >> n; //n条边
	memset(h, -1, sizeof h);
	while (n--)
	{
		int a, b;
		cin >> a >> b; //无向图
		add(a, b);
		add(b, a);
	}
	dfs(1, -1);
	return 0;
}
```
    