[![hackmd-github-sync-badge](https://hackmd.io/ww9FEyhoQHmg1NHcomB-Ow/badge)](https://hackmd.io/ww9FEyhoQHmg1NHcomB-Ow)
# <center>数据结构

### 并查集
```
struct dsu
{
	vector<int>f,sz;
	dsu(int n)
	{
		f.resize(n);
		sz.resize(n,1);
		for(int i=0;i<n;i++) f[i] = i;
	}
	int find(int x)
	{
		return x==f[x] ? x : f[x] = find(f[x]);
	}
	void merge(int x,int y)
	{
		x = find(x);
		y = find(y);
		if(x == y) return ;
		if(sz[x] < sz[y]) swap(x,y);
		f[y] = x;
		sz[x] += sz[y];
		sz[y] = 0;
	}
};
```

### 线段树
#### 朴素线段树
##### 区间修改加减，区间查询
```
ll a[N];
int n, m;
inline int lc(int x)
{
	return x << 1;
}
inline int rc(int x)
{
	return x << 1 | 1;
}
struct Seg
{
	ll l, r, sum, tag;
	
} seg[N * 4];

void push_up(int cur)
{
	seg[cur].sum = seg[lc(cur)].sum + seg[rc(cur)].sum;
}
void build(int cur, int l, int r)
{
	seg[cur] = {l, r, 0, 0};
	if (l == r)
	{
		seg[cur].sum = a[l];
	}
	else
	{
		int mid = l + r >> 1;
		build(lc(cur), l, mid);
		build(rc(cur), mid + 1, r);
		push_up(cur);
	}
}
void push_down(int cur)
{
	auto &root = seg[cur], &ls = seg[lc(cur)], &rs = seg[rc(cur)];
	if (root.tag)
	{
		ls.tag += root.tag;
		rs.tag += root.tag;
		ls.sum += (ll)(ls.r - ls.l + 1) * root.tag;
		rs.sum += (ll)(rs.r - rs.l + 1) * root.tag;
		root.tag = 0;
	}
}
void add(int cur, int l, int r, int val)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].tag += val;
		seg[cur].sum += (ll)(seg[cur].r - seg[cur].l + 1) * val;
	}
	else
	{
		push_down(cur);
		int mid = seg[cur].l + seg[cur].r >> 1;
		if (l <= mid)
		{
			add(lc(cur), l, r, val);
		}
		if (r > mid)
		{
			add(rc(cur), l, r, val);
		}
		push_up(cur);
	}
}
ll que(int cur, int l, int r)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		return seg[cur].sum;
	}
	push_down(cur);
	ll ans = 0;
	int mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)
	{
		ans += que(lc(cur), l, r);
	}
	if (r > mid)
	{
		ans += que(rc(cur), l, r);
	}
	return ans;
}
```
##### 区间加，乘
要点：要先乘后加
模板参考
    [线段树加乘操作](https://www.luogu.com.cn/problem/P3373)
```
#include<bits/stdc++.h>

#define IO std::ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
const int N = 1000005;
using namespace std;
using ll = long long;
inline int lc(int x)
{
	return x << 1;
}
inline int rc(int x)
{
	return x << 1 | 1;
}
ll n, m, a[N], p;
struct Seg
{
	ll sum, l, r, mul, add;
} seg[N];
void pp(ll cur)
{
	seg[cur].sum = (seg[lc(cur)].sum + seg[rc(cur)].sum) % p;
}
void build(ll cur, ll l, ll r)
{
	seg[cur].l = l;
	seg[cur].r = r;
	seg[cur].mul = 1;
	if (l == r)
	{
		seg[cur].sum = a[l] % p;
		return;
	}
	int mid = l + r >> 1;
	build(lc(cur), l, mid);
	build(rc(cur), mid + 1, r);
	pp(cur);
}
void pd(ll cur)
{
	//先乘后加
	seg[lc(cur)].sum = (ll)(seg[cur].mul * seg[lc(cur)].sum + ((seg[lc(cur)].r - seg[lc(cur)].l + 1) * seg[cur].add) % p) % p;
	seg[rc(cur)].sum = (ll)(seg[cur].mul * seg[rc(cur)].sum + ((seg[rc(cur)].r - seg[rc(cur)].l + 1) * seg[cur].add) % p) % p;

	seg[lc(cur)].mul = (ll)(seg[cur].mul * seg[lc(cur)].mul) % p;
	seg[rc(cur)].mul = (ll)(seg[cur].mul * seg[rc(cur)].mul) % p;

	seg[lc(cur)].add = (ll)(seg[lc(cur)].add * seg[cur].mul + seg[cur].add) % p;
	seg[rc(cur)].add = (ll)(seg[rc(cur)].add * seg[cur].mul + seg[cur].add) % p;

	//清零处理
	seg[cur].mul = 1;
	seg[cur].add = 0;
}
void add(ll cur, ll l, ll r, ll k)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].add = (seg[cur].add + k) % p;
		seg[cur].sum = (ll)(seg[cur].sum + k * (seg[cur].r - seg[cur].l + 1)) % p;
		return;
	}
	pd(cur);
	ll mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)add(lc(cur), l, r, k);
	if (mid < r)add(rc(cur), l, r, k);
	pp(cur);
}
void mul(ll cur, ll l, ll r, ll k)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		seg[cur].add = (seg[cur].add * k) % p;
		seg[cur].mul = (seg[cur].mul * k) % p;
		seg[cur].sum = (seg[cur].sum * k) % p;
		return;
	}
	pd(cur);
	ll mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)mul(lc(cur), l, r, k);
	if (mid < r)mul(rc(cur), l, r, k);
	pp(cur);
}
ll que(ll cur, ll l, ll r)
{
	if (seg[cur].l >= l and seg[cur].r <= r)
	{
		return seg[cur].sum;
	}
	pd(cur);
	ll ans = 0;
	ll mid = seg[cur].l + seg[cur].r >> 1;
	if (l <= mid)ans = (ans + que(lc(cur), l, r)) % p;
	if (mid < r)ans =  (ans + que(rc(cur), l, r)) % p;
	return ans;
}
void slove()
{
	cin >> n >> m >> p;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	build(1, 1, n);
	while (m--)
	{
		ll op, x, y, z;
		cin >> op ;
		if (op == 1)
		{
			cin >> x >> y >> z;
			mul(1, x, y, z);
		}
		else if (op == 2)
		{
			cin >> x >> y >> z;
			add(1, x, y, z);
		}
		else
		{
			cin >> x >> y;
			cout << que(1, x, y) << '\n';
		}
	}
}
int main()
{
	IO
	int _T = 1;
//	cin >> _T;
	while (_T--)
	{
		slove();
	}
	return (0 - 0);
}
```
## 暴力数据结构
### 珂朵莉树
#### 节点
一个节点表示一个值相同的区间
```
struct Node
{
	int l, r;
	mutable int v;
	Node (const int &_l, const int &_r, const int & _v)
	{
		l = _l;
		r = _r;
		v = _v;
	}
	inline bool operator < (const Node & a) const
	{
		return l < a.l;
	}
}
set<Node> odt;
```
#### split操作
将原本包含在点$x$的区间$[l,r]$分裂成为两个区间$[l,x)$和$[x,r]$并返回指向后者的迭代器
```
auto split(int x)
{
	if (x > n) return odt.end();
	auto it = --odt.upper_bound(Node{x, 0, 0}); //找首个不小于x的节点
	if (it -> l == x) return it; //没找到直接返回
	int l = it -> l, r = it -> r, v = it -> v;
	odt.erase(it);
	odt.insert(Node(l, x - 1, v));
	//insert函数返回pair，其中的first是新插入结点的迭代器
	return odt.insert(Node(x, r, v)).first;
}
```
#### assign
用于对一段区间进行赋值（可以替换成其他操作），这个是保证复杂度的关键。
这个里面也可以进行其他的操作，但是复杂度就没有办法保证了（也就是暴力计算类似于分块
```
void assign(int l, int r, int v)
{
	auto itr = split(r + 1), itl = split(l);
	odt.erase(itl, itr);
	odt.insert(Node(l, r, v));
}
```
#### 一些操作
##### 区间第$K$小
```
int rank(int l, int r, int k)
{
	//值 ，值的个数 第k小也要算上重复的
	vector<pair<int, int>> vec;
	auto itr = split(r + 1), itl = split(l);
	for (; itl != itr; ++itl)
	{
		vec.push_back({itl -> v, itl -> r - itl->l + 1});
	}
	sort(begin(vec), end(vec));
	for (auto it : vec)
	{
		k -= it.second;
		if (k <= 0) return it->first;
	}
}
```
##### 区间取反
对$[l,r]$里面的取反$O(r-l)$
```
void assign(int l, int r)
{
	auto itr = split(r + 1), itl = split(l);
	for (; itl != itr; itl++)itl->v ^= 1;
}
```
### ST表
$ans = max(f[x][lg[y - x + 1]], f[y - (1 << lg[y - x + 1]) + 1][lg[y - x + 1]])$
```
ll a[N];
ll f[N][30];
int lg[N];
void init()
{
	lg[1] = 0;
	for (int i = 2; i <= n; i++)lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i++)f[i][0] = a[i];
	for (int j = 1; j <= lg[n]; j++)
	{
		for (int i = 1; i <= n - (1 << j) + 1; i++)
		{
			f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
		}
	}
}
ll query(int x, int y)
{
	return max(f[x][lg[y - x + 1]], f[y - (1 << lg[y - x + 1]) + 1][lg[y - x + 1]]);
}
```
预处理$O(n\log n)$，查询$O(1)$

------------
### 分块
#### 查询
1. 若$L$和$R$在一个块内，直接使用暴力求和，块长为$S$，最坏复杂度为$O(S)$
2. 若L和R不在同一块内，这样答案就可能会由三个部分组成
	1. 以$L$开头的不完整的块 $\rarr$暴力计算 $O(S)$
	2. 中间的完整块$ \rarr $直接使用前缀和 $ O(\frac{R-L}{S})$
	3. 以$R$结尾的不完整块$\rarr$暴力计算$O(S)$    综合下来时间复杂度为$O(\frac{N}{S} + S)$
#### 修改
1. L和R在同一块内，暴力修改当前元素值和前缀和的值$\rarr O(S)$
2. L和R不在同一块内，可能需要修改到三个部分
	1. 以L开头的不完整块$\rarr O(S)$
	2. 中间的整块$\rarr O(\frac{R-L}{S})$
	3. 以R结尾的不完整块$\rarr O(S)$    综合下来时间复杂度为$O(\frac{N}{S} + S)$
	
根据均值不等式来计算 当$S =\sqrt n$的时候其时间复杂度最低为$O(\sqrt n)$
#### code
以[此](https://loj.ac/p/6280 "此")为例

```
#include <bits/stdc++.h>
using ll = long long;
const int N = 50005;
using namespace std;
//id块 长度
int id[N],len;
//数值  区间和 块长 
ll a[N],b[N],s[N];
int n;
void add(int l,int r,int x)
{
    int lid = id[l], rid = id[r];
    if(lid == rid)//同一块
    {
        for(int i = l;i <= r; i++)a[i] += x,s[lid] += x;
        return;
    }
	//左半边
    for(int i = l; id[i] == lid; i++)a[i] += x,s[lid] += x;
	//中间完整的块
    for(int i = lid + 1;i < rid; i++)b[i] += x，s[i] += len * x;
	//右半边
    for(int i = r;id[i] == rid; i--) a[i] += x,s[rid] += x;
  
}
ll query(int l,int r,ll p)
{
    int lid = id[l],rid = id[r];
    ll ans = 0;
    if(lid == rid) //在同一个区间里面 直接暴力加
    {
        for(int i = l;i <= r;i++) ans = (ans + a[i] + b[lid]) % p; 
        return ans;
    }
	//左半边
    for(int i = l; id[i] == lid; i++)ans = (ans + a[i] + b[lid]) % p;
	//中间完整的部分  直接加 块区间和
    for(int i = lid + 1;i < rid ;i++) ans = (ans + s[i]) % p;
	//右半边
    for(int i = r;id[i] == rid ;i--)ans = (ans + a[i] + b[rid])%p;
    return ans;
}
void slove()
{
    cin >> n;
    len = sqrt(n);//sqrt(n0的时间复杂度最优
    for(int i = 1;i <= n; i++) 
    {
        cin >> a[i];
        id[i] = (i-1) / len + 1; // set id
        s[id[i]] += a[i];//求取前缀和
    }
    for(int i = 1;i <= n; i++)
    {
        int op,l,r,c;
        cin >> op >> l >> r >>c;
        if(op == 0) add(l,r,c);
        else cout<<query(l,r,c + 1)<<'\n';
    }
}
int main()
{
  
    slove();
    return 0;
}
```

# <center>图论
### 简单图
#### 数组存图（邻接表）
h数组是邻接表的头它的下表是当前节点的标号，值是当前结点第一条边的编号（其实是最后加入的那一条边。

e数组是边的集合，它的下标是当前边的编号，数值是当前边的终点；
    
ne是nextedge，如果ne是-1表示当前结点没有下一条边，ne的下标是当前边的编号，数值是当前结点的下一条边的编号，idx用于保存每一条边的上一条边的编号。
    
这样我们就知道了当前结点的第一条边是几，这个边的终点是那个结点，该节点的下一条边编号是几，那么邻接表就完成了
```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int h[N], e[N], ne[N], idx;
void add(int a, int b)
{
	//图的创建
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}
void dfs(int u, int father)
{
	//图的遍历
	cout << u << endl;
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (j != father)
		{
			dfs(j, u);
		}
	}
}
int main()
{
	int n;
	cin >> n; //n条边
	memset(h, -1, sizeof h);
	while (n--)
	{
		int a, b;
		cin >> a >> b; //无向图
		add(a, b);
		add(b, a);
	}
	dfs(1, -1);
	return 0;
}
```
    
